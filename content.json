{"pages":[{"title":"categories","text":"","link":"/categories/index.html"}],"posts":[{"title":"单例模式","text":"模式是脱语言的,为了解决多个线程 操作不同的实例对象,多个线程要操作同一对象,要保证对象的唯一性 注意： 1、单例类只能有一个实例。 2、单例类必须自己创建自己的唯一实例。 3、单例类必须给所有其他对象提供这一实例。 饿汉式是否 Lazy 初始化：否 是否多线程安全：是 实现难度：易 描述：这种方式比较常用，但容易产生垃圾对象。优点：没有加锁，执行效率会提高。缺点：类加载时就初始化，浪费内存。 1234567public class HungrySingleDemo { private static HungrySingleDemo instance=new HungrySingleDemo(); private HungrySingleDemo(){} public static HungrySingleDemo getInstance(){ return instance; }} 双检锁/双重校验锁（DCL，即 double-checked locking）是否 Lazy 初始化：是 是否多线程安全：是 实现难度：较复杂 描述：这种方式采用双锁机制，安全且在多线程情况下能保持高性能。volatile避免因为指令重排引起不必要的空指针异常 123456789101112131415public class DoubleCheckDemo { private static volatile DoubleCheckDemo instance=null; private DoubleCheckDemo() { } public static DoubleCheckDemo getInstance(){ if (instance==null){ synchronized (DoubleCheckDemo.class){ if (instance==null){ instance=new DoubleCheckDemo(); } } } return instance; }} Holder/静态内部类是否 Lazy 初始化：是 是否多线程安全：是 实现难度：一般 描述：这种方式能达到双检锁方式一样的功效，但实现更简单。对静态域使用延迟初始化，应使用这种方式而不是双检锁方式。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用 123456789public class HolderDemo { private HolderDemo(){}; private static class Holder{ private static HolderDemo instance=new HolderDemo(); } public static HolderDemo getInstance(){ return Holder.instance; }} 枚举是否 Lazy 初始化：是 是否多线程安全：是 实现难度：易 描述：这种实现方式还没有被广泛采用，但这是实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化。 1234567891011121314151617public class EnumSingleDemo { private EnumSingleDemo(){} private enum EnumHolder{ Instance; private EnumSingleDemo instance; EnumHolder(){ this.instance=new EnumSingleDemo(); } private EnumSingleDemo getInstance(){ return instance; } } public static EnumSingleDemo getInstance(){ return EnumHolder.Instance.getInstance(); }}","link":"/2020/02/27/single/single/"},{"title":"深入了解Java内存模型","text":"线程与JVM java内存区域与java内存模型的区别 硬件内存架构与java内存模型 java内存模型对并发特征的保证 ​ 基本概念： ​ 程序：代码，完成某一件任务，代码序列（静态的概念） ​ 进程：程序在某些数据上的一次运行（动态的概念） ​ 线程：一个进程可能包含一个或多个线程（占有资源的独立单元） java 内存区域 方法区 : 类信息,常量,static,JIT; (信息共享) java 堆区 : 实例对象 , GC; (信息共享) VM Stack : java 方法在运行的内存模型 PC : java 线程的私有数据,这个数据就是执行下一条指令的地址 java 内存模型 JMM( 规范,抽象的模型) 主内存: 共享的信息 工作类存 : 私有的信息 ,基本的数据类型,直接存放在工作空间,引用数据类型,引用的地址放在工作空间,引用的对象放在堆中 工作方式 : 线程修改私有的数据 ,直接在工作空间修改 线程修改共享数据, 先把数据复制到工作空间,在工作空间进行修改,修改完成以后再刷新主存区的数据 硬件内存架构与java 内存模型硬件架构 : ​ CPU 缓存的一致性问题 : 并发处理的不同步 ​ 解决方案 : 总线加锁 , 降低cpu 的吞吐量 缓存上的一致性协议(MESI) 当cpu 在 cache 中 操作数据行, 如果该数据是共享变量 ,数据在cache 读到寄存器中, 进行修改,并更新内存数据,cache line 置无效,其它的cup就从内存中去读取数据 java 内存模型与硬件架构的关系​ ​ 交叉 : 数据的不一致 并发编程的三个重要的特性 ​ 原子性: 不可分割 ​ 可见性: 线程只能操作自己工作空间的数据 ​ 有序性: 程序中的顺序不一定就是执行的顺序 编译重排序 指令重排序 提高效率 (和指令操作的时间有关系) 重排规则 as-if-seria : 单线程中重排不影响执行的结果 happens-before : JMM对三个特征到的保证1) .JMM 与原子性 ​ x =10 写 原子性 如果是私有数据,具有原子性,如果是共享数据没有原子性 ​ y=x (没有原子性) 把数据x 读到工作空间 (原子性), 把 x 的值写到y (原子性), ​ i++ (没有原子性) 读 i 到工作空间, +1, 刷新结果到内存 ​ Z=z+1 (没有原子性) 读 z到工作空间, +1, 刷新结果到内存 多个原子性操作合并到一起没有原子性 保证方式 : synchronized , JUC : Lock 的 lock 2) . JMM与可见性 ​ Volatile : 在JMM模式上实现 EMSI协议 ​ synchronized : 加锁 ​ JUC : Lock 的 lock -3) .JMM有序性 ​ Volatile synchronized Happens-before原则： 程序次序原则 锁定原则 ：后一次加锁必须等前一次解锁 Volatile原则：霸道原则 传递原则：A—B —C A–C","link":"/2020/01/21/jvm/java_JVM/"},{"title":"接口和抽象类","text":"抽象类:如果一个类中包含了抽象方法，那么这个类就是抽象类。在Java中可以通过把某些方法声明abstract(abstract只能用来修饰类或者方法不能用来修饰属性)来表示一个类是抽象类。 接口就是一个方法的集合，接口中所有的方法都是没有方法体的，通过关键字interface来实现 相同点：1） 都不能被实例化 2） 接口的实现类或者抽象类的子类都只有实现了接口或抽象类中的方法后才能被实例化 不同点: 在Java8之前接口只有定义，其它方法不能再接口中实现(Java8之后接口中的方法可以有默认的实现)，只有实现了接口的类才能实现接中定义的方法。抽象类可以定义和实现，抽象类可以有抽象和非抽象的方法。 一个类可以实现(implements)多个接口，但是最多只能实现(extends)一个抽象类。因此接口可以间接的达到多重继承的目的 接口强调的是特定功能的实现,设计理念是一种”has - a”的关系,而抽象类强调的所属关系,其设计理念是”is - a”的关系(ps: has -a 这种事物(羊毛)属于那种事物的一部分(绵羊)! is - a 这种事物(绵羊)属于那种事物(羊)的一个种类) 接口中的成员(实例)变量默认为public static final 只能够有静态的不能被修改的数据成员,而且必须给其赋初值,接口中的方法只能用public 和 abstract修饰.但是抽象类不一定","link":"/2020/02/28/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB/"},{"title":"多态","text":"多态是同一个行为具有多个不同表现形式或形态的能力。 多态就是同一个接口，使用不同的实例而执行不同操作。 现实中，比如我们按下 F1 键这个动作： 如果当前在 Flash 界面下弹出的就是 AS 3 的帮助文档； 如果当前在 Word 下弹出的就是 Word 帮助； 在 Windows 下弹出的就是 Windows 帮助和支持。 同一个事件发生在不同的对象上会产生不同的结果。 多态的优点 消除类型之间的耦合关系 可替换性 可扩充性 接口性 灵活性 简化性 多态存在的三个必要条件 继承 重写 父类引用指向子类对象 当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，再去调用子类的同名方法。 多态的好处：可以使程序有良好的扩展，并可以对所有类的对象进行通用处理。","link":"/2020/02/28/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E5%A4%9A%E6%80%81/"},{"title":"springIOC(1)","text":"控制反转（Inversion of Control，缩写为IOC），是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫做依赖注入（Dependency Injection，简称DI），还有一种方式叫“依赖查找”（Dependency Lookup）, DI就是实现IOC的一种技术手段; spring编程的风格 schemal-based——-xml annotation-based—–annotation java-based—-java Configuration 三者的混合使用 1234@Configuration@ImportResource(\"classpath:spring-config.xml\")public class MyConfig {} 关于xml component-scan的使用 1&lt;context:component-scan base-package=\"org.liuyuqi\"/&gt; 配置了component-scan无需再配置以下配置 1&lt;context:annotation-config/&gt; 配置component-scan 之后自动开启注解配置 :p的使用 简化property 123xmlns:p=\"http://www.springframework.org/schema/p\" &lt;bean name=\"impl\" class=\"org.liuyuqi.IndexImpl\"/&gt; &lt;bean name=\"service\" class=\"org.liuyuqi.IndexService\" p:indexDao-ref=\"impl\"&gt; &lt;/bean&gt; 可以简化依赖关系的描述,在不使用:p的情况下为以下 1234&lt;bean name=\"impl\" class=\"org.liuyuqi.IndexImpl\"/&gt;&lt;bean name=\"service\" class=\"org.liuyuqi.IndexService\" &gt; &lt;property name=\"indexDao\" ref=\"impl\"/&gt;&lt;/bean&gt; 当然java类中也要描述依赖的关系 12345private IndexDao indexDao; public void setIndexDao(IndexDao indexDao) { this.indexDao = indexDao; } :c的使用 简化constructor 1234567891011 xmlns:c=\"http://www.springframework.org/schema/c\" &lt;bean name=\"impl\" class=\"org.liuyuqi.IndexImpl\"/&gt; &lt;bean name=\"service\" class=\"org.liuyuqi.IndexService\" c:indexDao-ref=\"impl\"&gt; &lt;/bean&gt;可以简化依赖关系的描述,在不使用:c的情况下为以下 &lt;bean name=\"service\" class=\"org.liuyuqi.IndexService\" &gt; &lt;constructor-arg name=\"indexDao\" ref=\"impl\"/&gt; &lt;/bean&gt; java类中描述依赖的关系 12345private IndexDao indexDao; public IndexService(IndexDao indexDao) { this.indexDao = indexDao; } spring 中的自动装配xml配置 :​ IOC的注入有两个地方需要提供依赖关系，一是类的定义中，二是在spring的配置中需要去描述。自动装配则把第二个取消了，即我们仅仅需要在类中提供依赖，继而把对象交给容器管理即可完成注入。 根据类型匹配 1default-autowire=&quot;byType 值得注意的是当类型有相同的实现类实现dao得时候比如以下代码 123&lt;bean name=\"impl\" class=\"org.liuyuqi.IndexImpl\"/&gt;&lt;bean name=\"impl2\" class=\"org.liuyuqi.IndexImpl2\"/&gt;&lt;bean name=\"service\" class=\"org.liuyuqi.IndexService\" /&gt; 都共同的实现了 1public class IndexImpl implements IndexDao 便会出现以下错误 这时候怎么解决 , 使用spring中的 byName 根据名称匹配 1default-autowire=\"byName 可以改变bean的名称以及类中set方法的属性让spring辨别 1234567891011121314151617181920&lt;bean name=\"indexDao\" class=\"org.liuyuqi.IndexImpl\"/&gt; public void setIndexDao(IndexDao indexDao) { this.indexDao = indexDao; }输出如下 impl1111 default-autowire=\"byName\"&gt;&lt;bean name=\"indexDao\" class=\"org.liuyuqi.IndexImpl\"/&gt;&lt;bean id=\"impl2\" class=\"org.liuyuqi.IndexImpl2\"/&gt;&lt;bean id=\"service\" class=\"org.liuyuqi.IndexService\" /&gt; public void setImpl2(IndexDao indexDao) { this.indexDao = indexDao; }输出如下 impl222 更自由的定义单独的定义匹配规格 autowire 1&lt;bean id=\"service\" class=\"org.liuyuqi.IndexService\" autowire=\"byName\"/&gt;","link":"/2020/03/03/spring/IOC/springIOC1/"}],"tags":[],"categories":[{"name":"设计模式","slug":"设计模式","link":"/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"JVM","slug":"JVM","link":"/categories/JVM/"},{"name":"java面向对象","slug":"java面向对象","link":"/categories/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"name":"spring","slug":"spring","link":"/categories/spring/"}]}