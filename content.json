{"pages":[{"title":"categories","text":"","link":"/categories/index.html"}],"posts":[{"title":"深入了解Java内存模型","text":"线程与JVM java内存区域与java内存模型的区别 硬件内存架构与java内存模型 java内存模型对并发特征的保证 ​ 基本概念： ​ 程序：代码，完成某一件任务，代码序列（静态的概念） ​ 进程：程序在某些数据上的一次运行（动态的概念） ​ 线程：一个进程可能包含一个或多个线程（占有资源的独立单元） java 内存区域 方法区 : 类信息,常量,static,JIT; (信息共享) java 堆区 : 实例对象 , GC; (信息共享) VM Stack : java 方法在运行的内存模型 PC : java 线程的私有数据,这个数据就是执行下一条指令的地址 java 内存模型 JMM( 规范,抽象的模型) 主内存: 共享的信息 工作类存 : 私有的信息 ,基本的数据类型,直接存放在工作空间,引用数据类型,引用的地址放在工作空间,引用的对象放在堆中 工作方式 : 线程修改私有的数据 ,直接在工作空间修改 线程修改共享数据, 先把数据复制到工作空间,在工作空间进行修改,修改完成以后再刷新主存区的数据 硬件内存架构与java 内存模型硬件架构 : ​ CPU 缓存的一致性问题 : 并发处理的不同步 ​ 解决方案 : 总线加锁 , 降低cpu 的吞吐量 缓存上的一致性协议(MESI) 当cpu 在 cache 中 操作数据行, 如果该数据是共享变量 ,数据在cache 读到寄存器中, 进行修改,并更新内存数据,cache line 置无效,其它的cup就从内存中去读取数据 java 内存模型与硬件架构的关系​ ​ 交叉 : 数据的不一致 并发编程的三个重要的特性 ​ 原子性: 不可分割 ​ 可见性: 线程只能操作自己工作空间的数据 ​ 有序性: 程序中的顺序不一定就是执行的顺序 编译重排序 指令重排序 提高效率 (和指令操作的时间有关系) 重排规则 as-if-seria : 单线程中重排不影响执行的结果 happens-before : JMM对三个特征到的保证1) .JMM 与原子性 ​ x =10 写 原子性 如果是私有数据,具有原子性,如果是共享数据没有原子性 ​ y=x (没有原子性) 把数据x 读到工作空间 (原子性), 把 x 的值写到y (原子性), ​ i++ (没有原子性) 读 i 到工作空间, +1, 刷新结果到内存 ​ Z=z+1 (没有原子性) 读 z到工作空间, +1, 刷新结果到内存 多个原子性操作合并到一起没有原子性 保证方式 : synchronized , JUC : Lock 的 lock 2) . JMM与可见性 ​ Volatile : 在JMM模式上实现 EMSI协议 ​ synchronized : 加锁 ​ JUC : Lock 的 lock -3) .JMM有序性 ​ Volatile synchronized Happens-before原则： 程序次序原则 锁定原则 ：后一次加锁必须等前一次解锁 Volatile原则：霸道原则 传递原则：A—B —C A–C","link":"/2020/01/21/jvm/java_JVM/"},{"title":"单例模式","text":"模式是脱语言的,为了解决多个线程 操作不同的实例对象,多个线程要操作同一对象,要保证对象的唯一性 注意： 1、单例类只能有一个实例。 2、单例类必须自己创建自己的唯一实例。 3、单例类必须给所有其他对象提供这一实例。 饿汉式 是否 Lazy 初始化：否 是否多线程安全：是 实现难度：易 描述：这种方式比较常用，但容易产生垃圾对象。优点：没有加锁，执行效率会提高。缺点：类加载时就初始化，浪费内存。 1234567public class HungrySingleDemo { private static HungrySingleDemo instance=new HungrySingleDemo(); private HungrySingleDemo(){} public static HungrySingleDemo getInstance(){ return instance; }} 双检锁/双重校验锁（DCL，即 double-checked locking）是否 Lazy 初始化：是 是否多线程安全：是 实现难度：较复杂 描述：这种方式采用双锁机制，安全且在多线程情况下能保持高性能。volatile避免因为指令重排引起不必要的空指针异常 123456789101112131415public class DoubleCheckDemo { private static volatile DoubleCheckDemo instance=null; private DoubleCheckDemo() { } public static DoubleCheckDemo getInstance(){ if (instance==null){ synchronized (DoubleCheckDemo.class){ if (instance==null){ instance=new DoubleCheckDemo(); } } } return instance; }} Holder/静态内部类是否 Lazy 初始化：是 是否多线程安全：是 实现难度：一般 描述：这种方式能达到双检锁方式一样的功效，但实现更简单。对静态域使用延迟初始化，应使用这种方式而不是双检锁方式。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用 123456789public class HolderDemo { private HolderDemo(){}; private static class Holder{ private static HolderDemo instance=new HolderDemo(); } public static HolderDemo getInstance(){ return Holder.instance; }} 枚举是否 Lazy 初始化：是 是否多线程安全：是 实现难度：易 描述：这种实现方式还没有被广泛采用，但这是实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化。 1234567891011121314151617public class EnumSingleDemo { private EnumSingleDemo(){} private enum EnumHolder{ Instance; private EnumSingleDemo instance; EnumHolder(){ this.instance=new EnumSingleDemo(); } private EnumSingleDemo getInstance(){ return instance; } } public static EnumSingleDemo getInstance(){ return EnumHolder.Instance.getInstance(); }}","link":"/2020/02/27/single/single/"}],"tags":[],"categories":[{"name":"JVM","slug":"JVM","link":"/categories/JVM/"},{"name":"设计模式","slug":"设计模式","link":"/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]}