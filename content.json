{"pages":[{"title":"categories","text":"","link":"/categories/index.html"}],"posts":[{"title":"深入了解Java内存模型","text":"线程与JVM java内存区域与java内存模型的区别 硬件内存架构与java内存模型 java内存模型对并发特征的保证 ​ 基本概念： ​ 程序：代码，完成某一件任务，代码序列（静态的概念） ​ 进程：程序在某些数据上的一次运行（动态的概念） ​ 线程：一个进程可能包含一个或多个线程（占有资源的独立单元） java 内存区域 方法区 : 类信息,常量,static,JIT; (信息共享) java 堆区 : 实例对象 , GC; (信息共享) VM Stack : java 方法在运行的内存模型 PC : java 线程的私有数据,这个数据就是执行下一条指令的地址 java 内存模型 JMM( 规范,抽象的模型) 主内存: 共享的信息 工作类存 : 私有的信息 ,基本的数据类型,直接存放在工作空间,引用数据类型,引用的地址放在工作空间,引用的对象放在堆中 工作方式 : 线程修改私有的数据 ,直接在工作空间修改 线程修改共享数据, 先把数据复制到工作空间,在工作空间进行修改,修改完成以后再刷新主存区的数据 硬件内存架构与java 内存模型硬件架构 : ​ CPU 缓存的一致性问题 : 并发处理的不同步 ​ 解决方案 : 总线加锁 , 降低cpu 的吞吐量 缓存上的一致性协议(MESI) 当cpu 在 cache 中 操作数据行, 如果该数据是共享变量 ,数据在cache 读到寄存器中, 进行修改,并更新内存数据,cache line 置无效,其它的cup就从内存中去读取数据 java 内存模型与硬件架构的关系​ ​ 交叉 : 数据的不一致 并发编程的三个重要的特性 ​ 原子性: 不可分割 ​ 可见性: 线程只能操作自己工作空间的数据 ​ 有序性: 程序中的顺序不一定就是执行的顺序 编译重排序 指令重排序 提高效率 (和指令操作的时间有关系) 重排规则 as-if-seria : 单线程中重排不影响执行的结果 happens-before : JMM对三个特征到的保证1) .JMM 与原子性 ​ x =10 写 原子性 如果是私有数据,具有原子性,如果是共享数据没有原子性 ​ y=x (没有原子性) 把数据x 读到工作空间 (原子性), 把 x 的值写到y (原子性), ​ i++ (没有原子性) 读 i 到工作空间, +1, 刷新结果到内存 ​ Z=z+1 (没有原子性) 读 z到工作空间, +1, 刷新结果到内存 多个原子性操作合并到一起没有原子性 保证方式 : synchronized , JUC : Lock 的 lock 2) . JMM与可见性 ​ Volatile : 在JMM模式上实现 EMSI协议 ​ synchronized : 加锁 ​ JUC : Lock 的 lock -3) .JMM有序性 ​ Volatile synchronized Happens-before原则： 程序次序原则 锁定原则 ：后一次加锁必须等前一次解锁 Volatile原则：霸道原则 传递原则：A—B —C A–C","link":"/2020/01/21/jvm/java_JVM/"}],"tags":[],"categories":[{"name":"JVM","slug":"JVM","link":"/categories/JVM/"}]}